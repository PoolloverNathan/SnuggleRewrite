package representation.passes.lowering

import org.objectweb.asm.Label
import representation.asts.ir.GeneratedType
import representation.asts.ir.Instruction
import representation.asts.typed.FieldDef
import representation.asts.typed.MethodDef
import representation.asts.typed.TypeDef
import representation.asts.typed.TypedExpr
import representation.passes.typing.isFallible
import util.Cons
import util.ConsList
import util.caching.IdentityIncrementalCalculator

/**
 * Lowering an expression into IR.
 *
 * desiredFields is a concept related to the implementation of fields of plural types.
 *
 * If you have a plural type, like a tuple, stored as a local variable, the implementation
 * in the runtime is to instead have multiple local variables, one for each element
 * of the tuple. (This recurses if an element of the tuple is also a plural type).
 * Say, for instance, you have a field-get expression ((x).y).z, where x is a local variable
 * with plural type, y is a field of x that has a plural type, and z is a field of that
 * plural type. The progression of the calls would be as follows:
 * - lowerExpr "((x).y).z", desiredFields = []
 * - lowerExpr "(x).y", desiredFields = ["z"]
 * - lowerExpr "x", desiredFields = ["y", "z"]
 * Then, the handler for "local variable" (which is what x is) will take
 * the desired fields into account, and select the correct backing field.
 * In short:
 * DesiredFields are generated by Field* expressions, and consumed by other expressions.
 *
 * Addition: DesiredFields can now be passed "through" bytecode method calls, to their
 * receivers. Also, desired fields can be a list of multiple cons lists. The reason is
 * that certain operations may want multiple discontiguous groups of desired fields.
 * For example, take an Option<Vec3>, and you call .get().y on it. The `.get()` bytecode
 * method call will pass along the desired field ["y"], as well as the other desired field
 * ["isPresent"]. (Ignoring the fields x and z).
 *
 * The length of desiredFields should always be at least 1.
 */

// I hope these "sequence {}" blocks aren't slow since they're really convenient
fun lowerExpr(expr: TypedExpr, desiredFields: ConsList<ConsList<FieldDef>>, typeCalc: IdentityIncrementalCalculator<TypeDef, GeneratedType>): Sequence<Instruction> = when (expr) {
    // Just a RunImport
    is TypedExpr.Import -> sequenceOf(Instruction.RunImport(expr.file))
    // Sequence the operations inside the block
    is TypedExpr.Block -> sequence {
        for (i in 0 until expr.exprs.size - 1) {
            yieldAll(lowerExpr(expr.exprs[i], ConsList.of(ConsList.nil()), typeCalc))
            yield(Instruction.Pop(expr.exprs[i].type))
        }
        yieldAll(lowerExpr(expr.exprs.last(), desiredFields, typeCalc))
    }
    // What to do for a declaration depends on the type of pattern
    is TypedExpr.Declaration -> sequence {
        // Yield the things
        if (isFallible(expr.pattern)) {
            TODO()
        } else {
            // Push the initializer
            yieldAll(lowerExpr(expr.initializer, ConsList.of(ConsList.nil()), typeCalc))
            // Apply the pattern
            yieldAll(lowerPattern(expr.pattern, typeCalc))
//            // Store/bind local variable
//            yield(Instruction.StoreLocal(expr.variableIndex, expr.pattern.type))
            // Push true
            yield(Instruction.Push(true, expr.type))
        }
    }

    // Extracted to special method, since it's complex
    is TypedExpr.Assignment -> handleAssignment(expr.lhs, expr.rhs, ConsList.nil(), expr.maxVariable, typeCalc)

    // Load the local variable
    is TypedExpr.Variable -> sequence {
        for (fieldGroup in desiredFields) {
            val wantedType = fieldGroup.lastOrNull()?.type ?: expr.type
            var startIndex = expr.variableIndex + getPluralOffset(fieldGroup)
            if (wantedType.isPlural) {
                for ((_, field) in wantedType.recursiveNonStaticFields) {
                    yield(Instruction.LoadLocal(startIndex, field.type))
                    startIndex += field.type.stackSlots
                }
            } else {
                yield(Instruction.LoadLocal(startIndex, wantedType))
            }
        }
    }

    // Push the literal
    is TypedExpr.Literal -> sequenceOf(Instruction.Push(expr.value, expr.type))

    is TypedExpr.FieldAccess -> sequence {
        if (expr.receiver.type.isReferenceType) {
            // If the receiver is a reference type, then
            // we don't need to pass the fields further down.
            // Instead, we handle them all here.
            // Compile the receiver: (which yields a reference type on the stack)
            yieldAll(lowerExpr(expr.receiver, ConsList.of(ConsList.nil()), typeCalc))
            val numberOfGroups = desiredFields.count()
            // If there are multiple fields groups, or if any particular field group is plural with > 1 elem,
            // need to store the receiver as a local variable.
            val neededToStoreLocal = numberOfGroups > 1 || desiredFields.any {
                val lastField = it.lastOrNull() ?: expr.fieldDef
                lastField.type.isPlural && lastField.type.recursiveNonStaticFields.size > 1
            }
            if (neededToStoreLocal)
                yield(Instruction.StoreLocal(expr.maxVariable, expr.receiver.type))
            for (fieldGroup in desiredFields) {
                // Now, we follow back up the list of desired fields.
                val namePrefix = fieldGroup.fold(expr.fieldName) {prefix, field -> prefix + "$" + field.name}
                // If the last field in the chain is plural, then we need multiple operations; otherwise just one.
                val lastField = fieldGroup.lastOrNull() ?: expr.fieldDef
                if (lastField.type.isPlural) {
                    // If the last field in the chain is plural, store the reference type
                    // as a top local variable, then repeatedly grab it and GetReferenceTypeField.
                    for ((pathToField, field) in lastField.type.recursiveNonStaticFields) {
                        if (neededToStoreLocal)
                            yield(Instruction.LoadLocal(expr.maxVariable, expr.receiver.type))
                        yield(Instruction.GetReferenceTypeField(expr.receiver.type, field.type, namePrefix + "$" + pathToField))
                    }
                } else {
                    // If not, then simply grab the field with the name prefix.
                    if (neededToStoreLocal)
                        yield(Instruction.LoadLocal(expr.maxVariable, expr.receiver.type))
                    yield(Instruction.GetReferenceTypeField(expr.receiver.type, lastField.type, namePrefix))
                }
            }
        } else if (expr.receiver.type.isPlural) {
            // Otherwise, if the receiver is not a reference type,
            // but is instead plural, we will pass the problem
            // down a level, by consing a new field def onto each
            // desired field group.
            yieldAll(lowerExpr(expr.receiver, desiredFields.map { Cons(expr.fieldDef, it) }, typeCalc))
        } else {
            // Any type that has accessible fields should either be a reference
            // type, or plural. This is a bug!
            throw IllegalStateException("Types with accessible fields should be either reference types or plural - " +
                    "but type \"${expr.receiver.type.name}\" is neither! Whoever implemented this type has made " +
                    "a mistake. Please contact them!")
        }
    }
    is TypedExpr.StaticFieldAccess -> sequence {
        for (fieldGroup in desiredFields) {
            // Similar code to the "if reference type" branch of the regular field access.
            val namePrefix = fieldGroup.fold(expr.fieldName) {prefix, field -> prefix + "$" + field.name}
            val lastField = fieldGroup.lastOrNull() ?: expr.fieldDef
            if (lastField.type.isPlural) {
                for ((pathToField, field) in lastField.type.recursiveNonStaticFields)
                    yield(Instruction.GetStaticField(expr.receiverType, field.type, namePrefix + "$" + pathToField))
            } else {
                yield(Instruction.GetStaticField(expr.receiverType, lastField.type, lastField.name))
            }
        }
    }

    // Compile arguments, make call
    is TypedExpr.MethodCall -> sequence {
        // Pre-bytecode if needed
        if (expr.methodDef is MethodDef.BytecodeMethodDef && expr.methodDef.preBytecode != null)
            yield(Instruction.Bytecodes(0) { expr.methodDef.preBytecode!!(it, expr.maxVariable, desiredFields) })
        val receiverDesiredFields = if (expr.methodDef is MethodDef.BytecodeMethodDef && expr.methodDef.desiredReceiverFields != null)
                expr.methodDef.desiredReceiverFields!!(desiredFields)
            else ConsList.of(ConsList.nil())

        yieldAll(lowerExpr(expr.receiver, receiverDesiredFields, typeCalc))
        for (arg in expr.args)
            yieldAll(lowerExpr(arg, ConsList.of(ConsList.nil()), typeCalc))
        if (expr.methodDef.owningType.unwrap() is TypeDef.ClassDef)
            yieldAll(createCall(expr.methodDef, desiredFields, expr.maxVariable) { Instruction.MethodCall.Virtual(it) })
        else
            yieldAll(createCall(expr.methodDef, desiredFields, expr.maxVariable) { Instruction.MethodCall.Static(it) })
    }
    is TypedExpr.StaticMethodCall -> sequence {
        lowerTypeDef(expr.receiverType, typeCalc)
        // Pre-bytecode if needed
        if (expr.methodDef is MethodDef.BytecodeMethodDef && expr.methodDef.preBytecode != null)
            yield(Instruction.Bytecodes(0) { expr.methodDef.preBytecode!!(it, expr.maxVariable, desiredFields) })
        for (arg in expr.args)
            yieldAll(lowerExpr(arg, ConsList.of(ConsList.nil()), typeCalc))
        yieldAll(createCall(expr.methodDef, desiredFields, expr.maxVariable) { Instruction.MethodCall.Static(it) })
    }
    is TypedExpr.SuperMethodCall -> sequence {
        // Pre-bytecode if needed
        if (expr.methodDef is MethodDef.BytecodeMethodDef && expr.methodDef.preBytecode != null)
            yield(Instruction.Bytecodes(0) { expr.methodDef.preBytecode!!(it, expr.maxVariable, desiredFields) })
        // Load "this" on the stack
        yield(Instruction.LoadRefType(expr.thisVariableIndex))
        // Push args
        for (arg in expr.args)
            yieldAll(lowerExpr(arg, ConsList.of(ConsList.nil()), typeCalc))
        // Create call
        yieldAll(createCall(expr.methodDef, desiredFields, expr.maxVariable) { Instruction.MethodCall.Special(it) })
    }
    is TypedExpr.ClassConstructorCall -> sequence {
        lowerTypeDef(expr.type, typeCalc)
        // Pre-bytecode if needed
        if (expr.methodDef is MethodDef.BytecodeMethodDef && expr.methodDef.preBytecode != null)
            yield(Instruction.Bytecodes(0) { expr.methodDef.preBytecode!!(it, expr.maxVariable, desiredFields) })
        // Push and dup the receiver
        yield(Instruction.NewRefAndDup(expr.type))
        // Push args
        for (arg in expr.args)
            yieldAll(lowerExpr(arg, ConsList.of(ConsList.nil()), typeCalc))
        yieldAll(createCall(expr.methodDef, desiredFields, expr.maxVariable) { Instruction.MethodCall.Special(it) })
    }
    is TypedExpr.RawStructConstructor -> sequence {
        var curFieldGroup = (desiredFields as Cons).elem
        for ((field, value) in expr.type.nonStaticFields.zip(expr.fieldValues)) {
            if (curFieldGroup is Cons && curFieldGroup.elem == field) {
                // We desire this field group specifically, so lower it
                yieldAll(lowerExpr(value, ConsList.of(curFieldGroup.rest), typeCalc))
                // Advance to next field group
                curFieldGroup = curFieldGroup.rest
            } else {
                // Yield the field value
                yieldAll(lowerExpr(value, ConsList.of(ConsList.nil()), typeCalc))
                // If we desire something specific, but this is not it, then pop the value
                if (curFieldGroup is Cons)
                    yield(Instruction.Pop(value.type))
            }
        }
        if (!curFieldGroup.isEmpty())
            throw IllegalStateException("Cur field group should be nil here - bug in compiler, please report")
    }

    is TypedExpr.Return -> sequence {
        // Yield the RHS, pushing it on the stack
        yieldAll(lowerExpr(expr.rhs, ConsList.of(ConsList.nil()), typeCalc))
        val returnType = expr.rhs.type
        // If it's plural, decompose into static field writes and one return.
        if (returnType.isPlural) {
            // Empty plural type: Just return void (null)
            if (returnType.recursiveNonStaticFields.isEmpty())
                yield(Instruction.Return(null))
            else {
                // The code here closely mirrors the code for getMethodResults.
                // This is where the static fields are STORED, and in getMethodResults,
                // they're READ.
                val namePrefix = "RETURN! "
                returnType.recursiveNonStaticFields.asReversed().dropLast(1).forEach { (pathToField, field) ->
                    // Put all except the first into static fields.
                    yield(Instruction.PutStaticField(returnType, field.type, namePrefix + "$" + pathToField))
                }
                // Return the last.
                yield(Instruction.Return(returnType.recursiveNonStaticFields.first().second.type))
            }
        } else {
            // If return type is not plural, just return normally.
            yield(Instruction.Return(returnType))
        }
    }

    is TypedExpr.If -> {
        val ifFalseLabel = Label()
        val doneLabel = Label()
        sequence {
            // Cond, jump if false to false branch
            yieldAll(lowerExpr(expr.cond, ConsList.of(ConsList.nil()), typeCalc))
            yield(Instruction.JumpIfFalse(ifFalseLabel))
            // True branch
            val loweredTrueBranch = lowerExpr(expr.ifTrue, ConsList.of(ConsList.nil()), typeCalc)
            yield(Instruction.CodeBlock(loweredTrueBranch.toList()))
            yield(Instruction.Jump(doneLabel))
            // False branch
            yield(Instruction.IrLabel(ifFalseLabel))
            val loweredFalseBranch = lowerExpr(expr.ifFalse, ConsList.of(ConsList.nil()), typeCalc)
            yield(Instruction.CodeBlock(loweredFalseBranch.toList()))
            // Done
            yield(Instruction.IrLabel(doneLabel))
        }
    }

    is TypedExpr.While -> {
        val condLabel = Label()
        val doneLabel = Label()
        sequence {
            // Push optional "none" on the stack
            yieldAll(lowerExpr(expr.neverRanAlternative, desiredFields, typeCalc))
            // Cond label
            yield(Instruction.IrLabel(condLabel))
            // Yield the lowered cond + jump as its own code block
            val loweredCond = sequence {
                yieldAll(lowerExpr(expr.cond, ConsList.of(ConsList.nil()), typeCalc))
                yield(Instruction.JumpIfFalse(doneLabel))
            }
            yield(Instruction.CodeBlock(loweredCond.toList()))
            // Yield the lowered body + jump as its own code block
            val loweredBody = sequence {
                yield(Instruction.Pop(expr.type))
                yieldAll(lowerExpr(expr.wrappedBody, ConsList.of(ConsList.nil()), typeCalc))
                yield(Instruction.Jump(condLabel))
            }
            yield(Instruction.CodeBlock(loweredBody.toList()))
            // Done label
            yield(Instruction.IrLabel(doneLabel))
        }
    }
}

private fun getPluralOffset(fieldsToFollow: ConsList<FieldDef>): Int = fieldsToFollow.sumOf { it.pluralOffset!! }

private inline fun createCall(
    methodDef: MethodDef, desiredFields: ConsList<ConsList<FieldDef>>,
    maxVariable: Int,
    crossinline snuggleCallType: (MethodDef.SnuggleMethodDef) -> Instruction.MethodCall
): Sequence<Instruction> {
    return when (methodDef) {
        is MethodDef.BytecodeMethodDef -> sequenceOf(Instruction.Bytecodes(0) { methodDef.bytecode(it, maxVariable, desiredFields) }) //TODO: Cost
        is MethodDef.InterfaceMethodDef -> sequenceOf(Instruction.MethodCall.Interface(methodDef))
        is MethodDef.CustomMethodDef -> methodDef.lowerer()
        // Invoke according to the snuggle call type
        is MethodDef.SnuggleMethodDef -> sequence {
            yield(snuggleCallType(methodDef))
            yieldAll(getMethodResults(methodDef, desiredFields))
        }
        is MethodDef.ConstMethodDef,
        is MethodDef.StaticConstMethodDef -> throw IllegalStateException("Cannot lower const method call - bug in compiler, please report")
        is MethodDef.GenericMethodDef<*> -> throw IllegalStateException("Cannot lower generic method call - bug in compiler, please report")
    }
}

/**
 * This handles fetching method results after a method call is made.
 * In most cases, the return is just a single value, and this doesn't
 * need to do anything.
 *
 * However, when the return value is a plural type with more than 1
 * element, this will need to grab most of them out of their static variables in the end.
 */
private fun getMethodResults(methodToCall: MethodDef, desiredFields: ConsList<ConsList<FieldDef>>): Sequence<Instruction> {
    return if (methodToCall.returnType.isPlural && methodToCall.returnType.recursiveNonStaticFields.size > 1) sequence {
        var first = true
        for (fieldGroup in desiredFields) {
            val namePrefix = fieldGroup.fold("RETURN! ") {prefix, field -> prefix + "$" + field.name}
            val lastDesiredType = fieldGroup.lastOrNull()?.type ?: methodToCall.returnType
            // If we have desired fields, and the first element of recursive nonstatic fields isn't one of them, then
            // pop it off the stack. Can only do this for the first fieldGroup.
            if (first && fieldGroup is Cons && fieldGroup.elem === methodToCall.returnType.nonStaticFields.first { it.type.stackSlots > 0 })
                yield(Instruction.Pop(methodToCall.returnType.recursiveNonStaticFields[0].second.type))
            // Grab whichever static fields we need off the stack
            lastDesiredType.recursiveNonStaticFields.asSequence().drop(1).forEach { (pathToField, field) ->
                yield(Instruction.GetStaticField(methodToCall.returnType, field.type, namePrefix + "$" + pathToField))
            }
            first = false
        }
    } else sequenceOf()
}

/**
 * Handle assignment to an lvalue, recursively (plural field accesses, etc)
 *
 * fieldsToFollow starts as nil.
 * assignmentType is the type being assigned to the lvalue.
 */
fun handleAssignment(lhs: TypedExpr, rhs: TypedExpr, fieldsToFollow: ConsList<FieldDef>, maxVariable: Int, typeCalc: IdentityIncrementalCalculator<TypeDef, GeneratedType>): Sequence<Instruction> = when {
    lhs is TypedExpr.Variable -> sequence {
        yieldAll(lowerExpr(rhs, ConsList.of(ConsList.nil()), typeCalc))
        val startIndex = lhs.variableIndex + getPluralOffset(fieldsToFollow)
        if (rhs.type.isPlural) {
            var curIndex = startIndex + rhs.type.stackSlots
            for ((_, field) in rhs.type.recursiveNonStaticFields.asReversed()) {
                curIndex -= field.type.stackSlots
                yield(Instruction.StoreLocal(curIndex, field.type))
            }
        } else {
            yield(Instruction.StoreLocal(startIndex, rhs.type))
        }
    }

    lhs is TypedExpr.StaticFieldAccess -> sequence {
        val namePrefix = fieldsToFollow.fold(lhs.fieldName) { prefix, field -> prefix + "$" + field.name }
        if (rhs.type.isPlural) {
            for ((pathToField, field) in rhs.type.recursiveNonStaticFields.asReversed())
                yield(Instruction.PutStaticField(lhs.receiverType, field.type, namePrefix + "$" + pathToField))
        } else {
            yield(Instruction.PutStaticField(lhs.receiverType, rhs.type, lhs.fieldName))
        }
    }

    lhs is TypedExpr.FieldAccess && lhs.receiver.type.isReferenceType -> sequence {
        yieldAll(lowerExpr(lhs.receiver, ConsList.of(ConsList.nil()), typeCalc))
        val namePrefix = fieldsToFollow.fold(lhs.fieldName) { prefix, field -> prefix + "$" + field.name }
        //TODO: Use a "neededToStore" like above to avoid storing as local for 1-elem structs
        if (rhs.type.isPlural) {
            // Store the reference type as a local, to grab later
            yield(Instruction.StoreLocal(maxVariable, lhs.receiver.type))
            // Emit the RHS onto the stack
            yieldAll(lowerExpr(rhs, ConsList.of(ConsList.nil()), typeCalc))
            // For each field, store it
            for ((pathToField, field) in rhs.type.recursiveNonStaticFields.asReversed()) {
                yield(Instruction.LoadLocal(maxVariable, lhs.receiver.type))
                yield(Instruction.SwapBasic(lhs.receiver.type, field.type))
                yield(Instruction.PutReferenceTypeField(lhs.receiver.type, field.type, namePrefix + "$" + pathToField))
            }
        } else {
            // Just set the field directly
            yieldAll(lowerExpr(rhs, ConsList.of(ConsList.nil()), typeCalc))
            yield(Instruction.PutReferenceTypeField(lhs.receiver.type, rhs.type, namePrefix))
        }
    }

    // Recursive case: The LHS is a field access, but its receiver is not a reference type.
    lhs is TypedExpr.FieldAccess -> handleAssignment(lhs.receiver, rhs, Cons(lhs.fieldDef, fieldsToFollow), maxVariable, typeCalc)

    else -> throw IllegalStateException("Illegal assignment case - bug in compiler, please report")
}